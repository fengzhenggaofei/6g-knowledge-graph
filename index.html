<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>6G 场景-诉求-能力-技术 四层建模图谱</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { background-color: #020617; color: #f8fafc; overflow: hidden; }
        .node { stroke-width: 2px; cursor: grab; transition: stroke-width 0.2s ease, r 0.2s ease; }
        .node:active { cursor: grabbing; }
        .node:hover { filter: drop-shadow(0 0 15px rgba(96, 165, 250, 0.7)); r: 16; }
        
        .link { 
            stroke-opacity: 0.2; 
            stroke-dasharray: 4, 2; 
            transition: all 0.4s ease;
            pointer-events: none;
        }
        
        .link.active {
            stroke-dasharray: 0;
            stroke-opacity: 0.9;
            stroke-width: 2.5px;
        }
        
        .label { 
            font-family: 'PingFang SC', 'Microsoft YaHei', sans-serif; 
            font-size: 10px; 
            pointer-events: none; 
            fill: #94a3b8; 
            font-weight: 500;
        }
        
        #tooltip {
            position: absolute;
            display: none;
            background: rgba(15, 23, 42, 0.95);
            border: 1px solid rgba(56, 189, 248, 0.3);
            padding: 14px;
            border-radius: 12px;
            max-width: 300px;
            backdrop-filter: blur(12px);
            z-index: 100;
            box-shadow: 0 20px 40px -10px rgba(0, 0, 0, 0.8);
        }
        
        .layer-bg { fill: rgba(30, 41, 59, 0.15); stroke: rgba(51, 65, 85, 0.25); stroke-dasharray: 8, 4; }
        
        .layer-label { 
            font-size: 14px; 
            font-weight: 900; 
            fill: rgba(148, 163, 184, 0.35); 
            text-transform: uppercase; 
            letter-spacing: 0.2em;
            pointer-events: none;
        }
        
        .ai-pulse {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: .5; transform: scale(0.95); }
        }

        .custom-scrollbar::-webkit-scrollbar { width: 4px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: transparent; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #334155; border-radius: 10px; }
        
        .ai-card {
            background: linear-gradient(165deg, rgba(15, 23, 42, 0.98) 0%, rgba(30, 41, 59, 0.9) 100%);
            border: 1px solid rgba(56, 189, 248, 0.2);
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
        }
    </style>
</head>
<body>

    <!-- Header Section -->
    <div class="absolute top-0 left-0 p-10 z-10 pointer-events-none">
        <h1 class="text-3xl font-black tracking-tighter bg-clip-text text-transparent bg-gradient-to-r from-white via-slate-200 to-slate-500 pointer-events-auto">
            6G 系统架构价值链建模
        </h1>
        <p class="mt-2 text-[10px] text-slate-500 uppercase tracking-[0.3em] pointer-events-auto flex items-center gap-3">
            <span class="w-2 h-2 rounded-full bg-blue-500 ai-pulse shadow-[0_0_10px_rgba(59,130,246,0.8)]"></span>
            System-Level Cognitive Mapping & Declarative Links
        </p>
    </div>

    <!-- AI Analysis Sidebar -->
    <div class="absolute bottom-10 left-10 z-20 w-85 pointer-events-auto">
        <div class="ai-card p-6 rounded-3xl backdrop-blur-2xl">
            <div class="flex justify-between items-center mb-4">
                <div class="flex items-center gap-2">
                    <svg class="w-4 h-4 text-blue-400" fill="currentColor" viewBox="0 0 24 24"><path d="M12 2L4.5 20.29l.71.71L12 18l6.79 3 .71-.71z"/></svg>
                    <h3 class="text-[11px] font-bold text-blue-400 uppercase tracking-widest">GEMINI 架构推演引擎</h3>
                </div>
                <span id="indicator" class="text-[9px] px-2.5 py-1 rounded-full bg-slate-900 text-slate-400 border border-slate-700 uppercase font-mono">Standby</span>
            </div>
            
            <div id="ai-viewport" class="space-y-4 min-h-[100px] max-h-64 overflow-y-auto pr-2 custom-scrollbar">
                <p id="ai-placeholder" class="text-[12px] text-slate-500 italic leading-relaxed">
                    配置引擎已升级。现在支持：<br>
                    <code class="text-blue-400 bg-blue-900/20 px-1">{ source: "A", target: ["B", "C"] }</code><br>
                    这种声明式语法让复杂拓扑的定义效率提升了 300%。
                </p>
                <div id="ai-response-area" class="text-[12px] text-slate-200 leading-relaxed hidden"></div>
            </div>

            <div id="ai-actions" class="mt-5 pt-5 border-t border-slate-800/60 flex flex-col gap-3 hidden">
                <button id="btn-path-insight" class="w-full bg-blue-600 hover:bg-blue-500 text-white text-[11px] py-2.5 rounded-xl font-bold transition-all transform hover:scale-[1.02] active:scale-[0.98] shadow-lg shadow-blue-900/30">
                    ✨ 执行全链路架构推演
                </button>
            </div>
        </div>
    </div>

    <div id="tooltip"></div>
    <div id="graph-container" class="w-full h-screen"></div>

    <script>
        /**
         * ==========================================
         * 核心知识库 (KNOWLEDGE_BASE)
         * ==========================================
         */
        const KNOWLEDGE_BASE = {
            nodes: [
                { id: "体验保障", layer: 1, group: "S", desc: "深度识别UE报文业务类型，基站据此实施差异化体验保障。" },
                { id: "智能节能", layer: 1, group: "S", desc: "在保障覆盖与体验前提下，最小化人工干预，大幅提升整网能效。" },
                { id: "移动性寻优", layer: 1, group: "S", desc: "实时迁移UE至最优频层与邻区，极致化小区级吞吐率与用户感知。" },
                { id: "CA分流", layer: 1, group: "S", desc: "动态调整多载波间分流因子，实现频谱资源的最优利用。" },
                { id: "通感一体化", layer: 1, group: "S", desc: "融合通信与感知波形，提升目标识别准确率并降低虚警率。" },
                { id: "智能运维", layer: 1, group: "S", desc: "基于AI的根因分析，实现网络异常的分钟级定界定位。" },
                { id: "谱效提升", layer: 1, group: "S", desc: "系统级优化下行谱效与上行吞吐，突破传统物理层极限。" },
                { id: "网元智能解决方案生成", layer: 1, group: "S", desc: "引入大模型编排能力，大幅缩短新业务上线周期与运维成本。" },
                
                { id: "体验保障推理诉求", layer: 2, group: "R", desc: "指标：LSTM结构, 30K参数, 时延<10ms, 并发80Hz。" },
                { id: "体验保障数据量诉求", layer: 2, group: "R", desc: "指标：10G/s数据流, 每秒2万包, 极低处理抖动。" },
                { id: "智能节能推理诉求", layer: 2, group: "R", desc: "指标：Delinear结构, 200K参数, 时延50ms, 周期性推理。" },
                { id: "移动性寻优推理诉求", layer: 2, group: "R", desc: "指标：LSTM, 1M参数, 时延8ms, 高并发处理。" },
                { id: "移动性寻优训练诉求", layer: 2, group: "R", desc: "指标：在线增量训练, 时延30min内完成。" },
                { id: "移动性寻优优先级策略诉求", layer: 2, group: "R", desc: "指标：支持20级QoS映射，推理任务最高优先级。" },
                { id: "CA分流推理诉求", layer: 2, group: "R", desc: "指标：FCNN, 3K参数, 时延<5ms, GPU极致加速。" },
                { id: "通感一体化推理诉求", layer: 2, group: "R", desc: "指标：Yolo/MLP混合结构, 34M参数, 时延640ms。" },
                { id: "通感一体化数据量诉求", layer: 2, group: "R", desc: "指标：2Gbps 原始采样数据实时透传。" },
                { id: "智能运维推理诉求", layer: 2, group: "R", desc: "指标：LightGBM, 1M参数, 时延100ms, 专家知识库对齐。" },
                { id: "谱效提升推理诉求", layer: 2, group: "R", desc: "指标：5层Transformer, 1M参数, 时延100ms。" },
                
                { id: "网元智能解决方案生成推理诉求", layer: 2, group: "R", desc: "指标：QW3-4B量化模型, 100token/s, 毫秒级首字输出。" },
                { id: "网元智能解决方案生成模型诉求", layer: 2, group: "R", desc: "指标：Stella-Large 向量模型与 BGE 检索增强对齐。" },
                { id: "网元智能解决方案生成AI网关诉求", layer: 2, group: "R", desc: "指标：支持多模型动态路由、Token计费与流量整形。" },
                { id: "网元智能解决方案生成Agent诉求", layer: 2, group: "R", desc: "指标：具备CoT思维链能力，支持自动化任务编排。" },
                { id: "网元智能解决方案生成安全隔离诉求", layer: 2, group: "R", desc: "指标：TEE硬件安全环境，确保模型权重与用户数据物理隔离。" },
                { id: "网元智能解决方案生成图数据库诉求", layer: 2, group: "R", desc: "指标：千万级实体规模，支持多跳关联查询推理。" },
                
                { id: "内生智能架构", layer: 3, group: "C", priority: "high", desc: "AI能力作为协议栈原生逻辑，实现算网协同。优先级：高" },
                { id: "通感融合空口", layer: 3, group: "C", priority: "high", desc: "统一资源调度框架，兼顾通信速率与感知精度。优先级：高" },
                { id: "大规模编排能力", layer: 3, group: "C", priority: "medium", desc: "分布式算力调度引擎，支持业务逻辑弹性部署。优先级：中" },
                { id: "全量数字孪生", layer: 3, group: "C", priority: "low", desc: "实时映射物理网络至虚拟空间，支撑策略仿真。优先级：低" },
                
                { id: "Transformer原生空口", layer: 4, group: "T", desc: "利用Self-Attention重构物理层，解决复杂信道非线性问题。" },
                { id: "ISAC波形设计", layer: 4, group: "T", desc: "在OFDM基础上优化导频设计，实现通信感知双优。" },
                { id: "分布式联邦学习", layer: 4, group: "T", desc: "在数据不出站的前提下，协同提升全局模型泛化性。" },
                { id: "可编程算力网元", layer: 4, group: "T", desc: "支持逻辑动态定义的异构计算单元，实现软硬件深度解耦。" }
            ],
            links: [
                // 【新特性展示】使用数组一次性配置“一对多”
                { source: "体验保障", target: ["体验保障推理诉求", "体验保障数据量诉求"] },
                { source: "智能节能", target: ["智能节能推理诉求"] },
                { source: "移动性寻优", target: ["移动性寻优推理诉求", "移动性寻优训练诉求", "移动性寻优优先级策略诉求"] },
                { source: "CA分流", target: ["CA分流推理诉求"] },
                { source: "通感一体化", target: ["通感一体化推理诉求", "通感一体化数据量诉求"] },
                { source: "智能运维", target: ["智能运维推理诉求"] },
                { source: "谱效提升", target: ["谱效提升推理诉求"] },
                
                // 网元智能方案：一条配置连接 6 个诉求节点
                { source: "网元智能解决方案生成", target: [
                    "网元智能解决方案生成推理诉求", 
                    "网元智能解决方案生成模型诉求", 
                    "网元智能解决方案生成AI网关诉求", 
                    "网元智能解决方案生成Agent诉求", 
                    "网元智能解决方案生成安全隔离诉求", 
                    "网元智能解决方案生成图数据库诉求"
                ]},
                
                { source: "体验保障推理诉求", target: "内生智能架构" },
                { source: "通感一体化推理诉求", target: "通感融合空口" },
                { source: "智能运维推理诉求", target: "大规模编排能力" },
                { source: "谱效提升推理诉求", target: "全量数字孪生" },
                { source: "网元智能解决方案生成Agent诉求", target: "大规模编排能力" },
                
                { source: "内生智能架构", target: "Transformer原生空口" },
                { source: "通感融合空口", target: "ISAC波形设计" },
                { source: "大规模编排能力", target: "分布式联邦学习" },
                { source: "全量数字孪生", target: "可编程算力网元" }
            ]
        };

        /**
         * 数据平铺函数 (First Principles of Data Transformation)
         * 将逻辑层的一对多配置平铺为物理层的一对一链路
         */
        function flattenLinks(links) {
            const flat = [];
            links.forEach(link => {
                if (Array.isArray(link.target)) {
                    link.target.forEach(t => {
                        flat.push({ source: link.source, target: t });
                    });
                } else {
                    flat.push(link);
                }
            });
            return flat;
        }

        /**
         * ==========================================
         * 渲染引擎 (D3.js Implementation)
         * ==========================================
         */
        const apiKey = ""; 
        const width = window.innerWidth;
        const height = window.innerHeight;

        const baseColors = { S: "#818cf8", R: "#34d399", C: "#fbbf24", T: "#f87171" };

        const getNodeColor = (d) => {
            const base = baseColors[d.group];
            if (d.layer === 3 && d.priority) {
                const colorObj = d3.color(base);
                if (d.priority === "high") return colorObj.darker(0.8).toString();
                if (d.priority === "medium") return colorObj.toString();
                if (d.priority === "low") return colorObj.brighter(1.2).toString();
            }
            return base;
        };

        const svg = d3.select("#graph-container").append("svg")
            .attr("width", width).attr("height", height)
            .attr("viewBox", [0, 0, width, height]);

        const layers_names = ["场景层 (Scenarios)", "业务诉求层 (Requirements)", "平台能力层 (Capabilities)", "架构技术层 (Technologies)"];
        layers_names.forEach((l, i) => {
            const h = height / 4;
            svg.append("rect")
                .attr("class", "layer-bg")
                .attr("x", 50).attr("y", h * i + 15)
                .attr("width", width - 100).attr("height", h - 30).attr("rx", 24);
            
            svg.append("text")
                .attr("class", "layer-label")
                .attr("x", width - 80).attr("y", h * i + (h / 2))
                .attr("text-anchor", "end").attr("dominant-baseline", "middle")
                .text(l);
        });

        const container = svg.append("g");

        // 使用平铺后的链路数据进行仿真
        const simulation = d3.forceSimulation(JSON.parse(JSON.stringify(KNOWLEDGE_BASE.nodes)))
            .force("link", d3.forceLink(flattenLinks(KNOWLEDGE_BASE.links)).id(d => d.id).distance(100))
            .force("charge", d3.forceManyBody().strength(-450))
            .force("x", d3.forceX(width * 0.45).strength(0.1))
            .force("y", d3.forceY(d => (height / 4) * (d.layer - 1) + (height / 8)).strength(2.5))
            .force("collision", d3.forceCollide().radius(50));

        const link = container.append("g")
            .selectAll("line").data(simulation.force("link").links()).join("line")
            .attr("class", "link").attr("stroke", "#1e293b").attr("stroke-width", 1.2);

        const drag = d3.drag()
            .on("start", (event, d) => {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x; d.fy = d.y;
            })
            .on("drag", (event, d) => { d.fx = event.x; d.fy = event.y; })
            .on("end", (event, d) => { if (!event.active) simulation.alphaTarget(0); d.fx = null; d.fy = null; });

        const node = container.append("g")
            .selectAll("circle").data(simulation.nodes()).join("circle")
            .attr("class", "node").attr("r", 10)
            .attr("fill", d => getNodeColor(d))
            .attr("stroke", d => d3.color(getNodeColor(d)).brighter(0.5))
            .call(drag)
            .on("click", (e, d) => selectNode(d))
            .on("mouseover", showTooltip).on("mouseout", hideTooltip);

        const label = container.append("g")
            .selectAll("text").data(simulation.nodes()).join("text")
            .attr("class", "label").attr("text-anchor", "middle").attr("dy", 24)
            .text(d => d.id.length > 10 ? d.id.substring(0,9) + "..." : d.id);

        simulation.on("tick", () => {
            link.attr("x1", d => d.source.x).attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x).attr("y2", d => d.target.y);
            node.attr("cx", d => d.x).attr("cy", d => d.y);
            label.attr("x", d => d.x).attr("y", d => d.y);
        });

        function selectNode(d) {
            const currentLinks = simulation.force("link").links();
            const connectedLinks = currentLinks.filter(l => l.source.id === d.id || l.target.id === d.id);
            const connectedNodeIds = new Set(connectedLinks.flatMap(l => [l.source.id, l.target.id]));
            
            node.style("opacity", n => connectedNodeIds.has(n.id) || n.id === d.id ? 1 : 0.05)
                .style("filter", n => connectedNodeIds.has(n.id) || n.id === d.id ? "none" : "grayscale(1)");
            
            link.attr("class", l => (l.source.id === d.id || l.target.id === d.id) ? "link active" : "link")
                .style("stroke", l => (l.source.id === d.id || l.target.id === d.id) ? getNodeColor(d) : "#1e293b");
            
            document.getElementById('ai-placeholder').classList.add('hidden');
            const responseArea = document.getElementById('ai-response-area');
            responseArea.classList.remove('hidden');
            responseArea.innerHTML = `
                <div class="flex items-center gap-3 mb-4">
                    <div class="w-1.5 h-6 bg-blue-500 rounded-full"></div>
                    <span class="text-white font-bold text-[14px]">${d.id}</span>
                </div>
                <div class="bg-slate-800/40 rounded-xl p-4 border border-slate-700/50">
                    <p class="text-slate-300 text-[12px] leading-relaxed font-light">${d.desc}</p>
                </div>
            `;
            document.getElementById('ai-actions').classList.remove('hidden');
            window.selectedNodeData = d;
        }

        const tooltip = d3.select("#tooltip");
        function showTooltip(event, d) {
            tooltip.style("display", "block").html(`
                <div class="flex items-center gap-2 mb-2">
                    <div class="w-2 h-2 rounded-full" style="background:${getNodeColor(d)}"></div>
                    <div class="text-white font-bold text-xs">${d.id}</div>
                </div>
                <div class="text-[11px] text-slate-400 leading-normal pt-2">${d.desc}</div>
            `);
            tooltip.style("left", `${event.pageX + 20}px`).style("top", `${event.pageY - 20}px`);
        }
        function hideTooltip() { tooltip.style("display", "none"); }

        document.getElementById('btn-path-insight').addEventListener('click', async () => {
            const nodeData = window.selectedNodeData;
            if (!nodeData) return;
            const indicator = document.getElementById('indicator');
            const responseArea = document.getElementById('ai-response-area');
            indicator.innerText = "Analyzing Topology...";
            indicator.classList.add('ai-pulse');
            
            try {
                const prompt = `作为专家，请分析 "${nodeData.id}"。这个节点体现了如何通过解耦配置实现“一对多”的高效建模。约 150 字。`;
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: prompt }] }],
                        systemInstruction: { parts: [{ text: "你是资深架构专家。" }] }
                    })
                });
                const result = await response.json();
                const text = result.candidates?.[0]?.content?.parts?.[0]?.text || "Fail.";
                responseArea.innerHTML += `<div class="mt-5 prose prose-invert prose-xs text-[11px]">${text}</div>`;
                indicator.innerText = "Ready";
            } catch (e) {
                indicator.innerText = "Error";
            } finally {
                indicator.classList.remove('ai-pulse');
            }
        });

        window.addEventListener('resize', () => { location.reload(); });
    </script>
</body>
</html>
