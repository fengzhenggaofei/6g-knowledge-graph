<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>6G 场景-诉求-能力-技术 四层建模图谱</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { background-color: #020617; color: #f8fafc; overflow: hidden; }
        .node { stroke-width: 2px; cursor: grab; transition: stroke-width 0.2s ease, r 0.2s ease; }
        .node:active { cursor: grabbing; }
        .node:hover { filter: drop-shadow(0 0 15px rgba(96, 165, 250, 0.7)); r: 16; }
        
        .link { 
            stroke-opacity: 0.2; 
            stroke-dasharray: 4, 2; 
            transition: all 0.4s ease;
            pointer-events: none;
        }
        
        .link.active {
            stroke-dasharray: 0;
            stroke-opacity: 0.9;
            stroke-width: 2.5px;
        }
        
        .label { 
            font-family: 'PingFang SC', 'Microsoft YaHei', sans-serif; 
            font-size: 10px; 
            pointer-events: none; 
            fill: #94a3b8; 
            font-weight: 500;
        }
        
        #tooltip {
            position: absolute;
            display: none;
            background: rgba(15, 23, 42, 0.95);
            border: 1px solid rgba(56, 189, 248, 0.3);
            padding: 14px;
            border-radius: 12px;
            max-width: 300px;
            backdrop-filter: blur(12px);
            z-index: 100;
            box-shadow: 0 20px 40px -10px rgba(0, 0, 0, 0.8);
        }
        
        .layer-bg { fill: rgba(30, 41, 59, 0.15); stroke: rgba(51, 65, 85, 0.25); stroke-dasharray: 8, 4; }
        
        .layer-label { 
            font-size: 14px; 
            font-weight: 900; 
            fill: rgba(148, 163, 184, 0.35); 
            text-transform: uppercase; 
            letter-spacing: 0.2em;
            pointer-events: none;
        }
        
        .ai-pulse {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: .5; transform: scale(0.95); }
        }

        .custom-scrollbar::-webkit-scrollbar { width: 4px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: transparent; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #334155; border-radius: 10px; }
        
        .ai-card {
            background: linear-gradient(165deg, rgba(15, 23, 42, 0.98) 0%, rgba(30, 41, 59, 0.9) 100%);
            border: 1px solid rgba(56, 189, 248, 0.2);
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
        }
    </style>
</head>
<body>

    <!-- Header Section -->
    <div class="absolute top-0 left-0 p-10 z-10 pointer-events-none">
        <h1 class="text-3xl font-black tracking-tighter bg-clip-text text-transparent bg-gradient-to-r from-white via-slate-200 to-slate-500 pointer-events-auto">
            6G 系统架构价值链建模
        </h1>
        <p class="mt-2 text-[10px] text-slate-500 uppercase tracking-[0.3em] pointer-events-auto flex items-center gap-3">
            <span class="w-2 h-2 rounded-full bg-blue-500 ai-pulse shadow-[0_0_10px_rgba(59,130,246,0.8)]"></span>
            System-Level Cognitive Mapping & Declarative Links
        </p>
    </div>

    <!-- AI Analysis Sidebar -->
    <div class="absolute bottom-10 left-10 z-20 w-85 pointer-events-auto">
        <div class="ai-card p-6 rounded-3xl backdrop-blur-2xl">
            <div class="flex justify-between items-center mb-4">
                <div class="flex items-center gap-2">
                    <svg class="w-4 h-4 text-blue-400" fill="currentColor" viewBox="0 0 24 24"><path d="M12 2L4.5 20.29l.71.71L12 18l6.79 3 .71-.71z"/></svg>
                    <h3 class="text-[11px] font-bold text-blue-400 uppercase tracking-widest">GEMINI 架构推演引擎</h3>
                </div>
                <span id="indicator" class="text-[9px] px-2.5 py-1 rounded-full bg-slate-900 text-slate-400 border border-slate-700 uppercase font-mono">Standby</span>
            </div>
            
            <div id="ai-viewport" class="space-y-4 min-h-[100px] max-h-64 overflow-y-auto pr-2 custom-scrollbar">
                <p id="ai-placeholder" class="text-[12px] text-slate-500 italic leading-relaxed">
                    配置引擎已升级。现在支持：<br>
                    <code class="text-blue-400 bg-blue-900/20 px-1">{ source: "A", target: ["B", "C"] }</code><br>
                    这种声明式语法让复杂拓扑的定义效率提升了 300%。
                </p>
                <div id="ai-response-area" class="text-[12px] text-slate-200 leading-relaxed hidden"></div>
            </div>

            <div id="ai-actions" class="mt-5 pt-5 border-t border-slate-800/60 flex flex-col gap-3 hidden">
                <button id="btn-path-insight" class="w-full bg-blue-600 hover:bg-blue-500 text-white text-[11px] py-2.5 rounded-xl font-bold transition-all transform hover:scale-[1.02] active:scale-[0.98] shadow-lg shadow-blue-900/30">
                    ✨ 执行全链路架构推演
                </button>
            </div>
        </div>
    </div>

    <div id="tooltip"></div>
    <div id="graph-container" class="w-full h-screen"></div>

    <script>
        /**
         * ==========================================
         * 核心知识库 (KNOWLEDGE_BASE)
         * ==========================================
         */
        const KNOWLEDGE_BASE = {
            nodes: [
                //layer1
                { id: "体验保障", layer: 1, group: "S", desc: "深度识别UE报文业务类型，基站据此实施差异化体验保障。" },
                { id: "智能节能", layer: 1, group: "S", desc: "在保障覆盖与体验前提下，最小化人工干预，大幅提升整网能效。" },
                { id: "移动性寻优", layer: 1, group: "S", desc: "实时迁移UE至最优频层与邻区，极致化小区级吞吐率与用户感知。" },
                { id: "CA分流", layer: 1, group: "S", desc: "动态调整多载波间分流因子，实现频谱资源的最优利用。" },
                { id: "通感一体化", layer: 1, group: "S", desc: "感知目标识别，提升目标对象识别准确率提升95%；多模感知融合降低感知虚警率到1%。" },
                { id: "智能运维", layer: 1, group: "S", desc: "基于AI的根因分析，实现网络异常的分钟级定界定位。" },
                { id: "谱效提升", layer: 1, group: "S", desc: "下行谱效提升5%，小区吞吐率提升20%，上行UE流量提升10%。" },
                { id: "网元智能解决方案生成", layer: 1, group: "S", desc: "引入大模型编排能力，人工运维工时减少90%，新服务上市时间缩短50%。" },

                //layer2
                { id: "体验保障推理诉求", layer: 2, group: "R", desc: "指标：LSTM结构, 30K参数, 时延<10ms, 并发80Hz。" },
                { id: "体验保障数据量诉求", layer: 2, group: "R", desc: "指标：10G/s数据流, 每秒2万包, 每包小于200Byte，极低处理抖动。" },
                { id: "智能节能推理诉求", layer: 2, group: "R", desc: "指标：Delinear结构, 200K参数, 时延50ms, 周期性推理(60s一次)。" },
                { id: "移动性寻优推理诉求", layer: 2, group: "R", desc: "指标：LSTM, 1M参数, 时延8ms, 高并发处理(100)。" },
                { id: "移动性寻优训练诉求", layer: 2, group: "R", desc: "指标：在线增量训练, 时延30min内完成。" },
                { id: "移动性寻优优先级策略诉求", layer: 2, group: "R", desc: "指标：支持20级QoS映射，推理任务最高优先级。" },
                { id: "CA分流推理诉求", layer: 2, group: "R", desc: "指标：FCNN, 3K参数, 时延<5ms, GPU极致加速(400/s)。" },
                { id: "通感一体化推理诉求", layer: 2, group: "R", desc: "指标：Yolo/MLP混合结构, 34M参数, 时延640ms,推理并发度(640ms)。" },
                { id: "通感一体化数据量诉求", layer: 2, group: "R", desc: "指标：2Gbps 原始采样数据实时透传。" },
                { id: "智能运维推理诉求", layer: 2, group: "R", desc: "指标：LightGBM, 1M参数, 时延100ms, 专家知识库对齐。" },
                { id: "谱效提升推理诉求", layer: 2, group: "R", desc: "指标：5层Transformer, 1M参数, 时延100ms。" },
                
                { id: "网元智能解决方案生成推理诉求", layer: 2, group: "R", desc: "指标：QW3-4B量化模型, 100token/s, 毫秒级首字输出。" },
                { id: "网元智能解决方案生成模型诉求", layer: 2, group: "R", desc: "指标：Stella-Large 向量模型与 BGE 检索增强对齐。" },
                { id: "网元智能解决方案生成AI网关诉求", layer: 2, group: "R", desc: "指标：支持多模型动态路由、Token计费与流量整形。" },
                { id: "网元智能解决方案生成Agent诉求", layer: 2, group: "R", desc: "指标：具备CoT思维链能力，支持自动化任务编排。" },
                { id: "网元智能解决方案生成安全隔离诉求", layer: 2, group: "R", desc: "指标：TEE硬件安全环境，确保模型权重与用户数据物理隔离。" },
                { id: "网元智能解决方案生成图数据库诉求", layer: 2, group: "R", desc: "指标：支持多跳关联查询推理。" },

                //layer3
                { id: "数据传输通道", layer: 3, group: "C", priority: "high", desc: "支持网元内、网元间的高效数据传输通道12Gpbs(<200Byte/包)，与业务数据隔离。优先级：高" },
                { id: "数据传输总线", layer: 3, group: "C", priority: "medium", desc: "支持高速数据面传输总线。优先级：中" },
                { id: "小模型生命周期管理", layer: 3, group: "C", priority: "high", desc: "支持小模型生命周期管理（模型下载，模型存储、热更新等）。优先级：高" },
                { id: "CPU小推理引擎", layer: 3, group: "C", priority: "high", desc: "支持基于CPU的小模型并发推理，大于200Hz。优先级：高" },
                { id: "小模型加载", layer: 3, group: "C", priority: "high", desc: "支持大于3000+小模型的加载能力，并且可以扩展。优先级：高" },
                { id: "小模型并发推理", layer: 3, group: "C", priority: "high", desc: "支持同一个小模型的多并发推理能力，10个，并且未来可以扩展。优先级：高" },
                { id: "小模型任务调度", layer: 3, group: "C", priority: "high", desc: "支持多个小模型模型的任务优先级调度管理。优先级：高" },
                { id: "小模型在线训练", layer: 3, group: "C", priority: "high", desc: "支持神经网络小模型的在线训练，模型验证和可用性评估。优先级：高" },
                { id: "小模型增训及评估", layer: 3, group: "C", priority: "high", desc: "支持小模型增训，及可用性评估。优先级：高" },
                { id: "GPU小推理引擎", layer: 3, group: "C", priority: "high", desc: "支持GPU多个小模型的并发推理, 大于400Hz。优先级：高" },
                { id: "GPU大模型加载", layer: 3, group: "C", priority: "medium", desc: "支持GPU大模型的加载（QW 4B，8bit量化）。优先级：中" },
                { id: "大小模型并发推理", layer: 3, group: "C", priority: "low", desc: "支持GPU大模型和小模型的并发推理。优先级：低" },
                { id: "embeding", layer: 3, group: "C", priority: "medium", desc: "支持embeding模型的部署。优先级：中" },
                { id: "规则库引擎", layer: 3, group: "C", priority: "high", desc: "支持规则库引擎CLIPS。优先级：高" },
                { id: "沙箱", layer: 3, group: "C", priority: "high", desc: "支持沙箱环境。优先级：高" },
                { id: "A2A&MCP", layer: 3, group: "C", priority: "low", desc: "支持A2A、MCP协议。优先级：低" },
                { id: "图数据库", layer: 3, group: "C", priority: "medium", desc: "支持图数据库。优先级：中" },
                { id: "AI协议网关", layer: 3, group: "C", priority: "low", desc: "支持AI协议网关。优先级：低" },
                { id: "Agent框架", layer: 3, group: "C", priority: "medium", desc: "支持网元智能体框架。优先级：中" },
                { id: "A/B版本", layer: 3, group: "C", priority: "high", desc: "支持模型A/B版本（模型增训/重训后 新模型在生产环境试用，验证新模型的业务提升效果）。优先级：高" },
                { id: "QoAIS", layer: 3, group: "C", priority: "high", desc: "支持推理任务的确定性时延保障（实时任务时延3ms，近实时任务10ms，一般任务）。优先级：高" },
                
                //layer4
                { id: "轻量化异构算力资源池化", layer: 4, group: "T", desc: "提供异构计算资源与调度能力，保障高性能推理与传输。" },
                { id: "轻量化高性能AI内生框架", layer: 4, group: "T", desc: "聚焦智能体运行、任务调度、模型推理、协同计算等。" },

                //layer5
                { "id": "异构算力管理与调度", "layer": 5, "group": "T", "priority": "high", "desc": "实现GPU/CPU异构算力编排、切片调度，满足支持GPU大模型和小模型的并发推理、支持同一个小模型的多并发推理能力。" },
                { "id": "容器编排基础设施", "layer": 5, "group": "T", "priority": "medium", "desc": "基于TCF/OCP（服务器场景）、以及LitePaaS（9200专用设备场景）实现容器管理和编排。" },
                { "id": "Serverless运行时", "layer": 5, "group": "T", "priority": "medium", "desc": "支持Serverless运行时，包括FaaS、BaaS等功能，通过Mecha机甲访问技术组件(数据库、网关、通信、推理框架、日志等）。" },
                { "id": "Agent沙箱执行环境", "layer": 5, "group": "T", "priority": "high", "desc": "通过进程隔离、容器隔离、安全容器隔离、轻量级虚机MicroVM隔离等方式实现Agent沙箱执行环境，满足支持沙箱环境。" },
                { "id": "高性能通信协议QUIC", "layer": 5, "group": "T", "priority": "high", "desc": "通过高性能通信协议QUIC实现协同与并行，满足支持网元内、网元间的高效数据传输通道12Gpbs、支持高速数据面传输总线。" },
                { "id": "分布式并行计算框架Ray", "layer": 5, "group": "T", "priority": "medium", "desc": "通过Ray实现网元内分布式并行计算框架，满足支持分布式并行计算框架（RAY）。" },
                { "id": "AI运行时", "layer": 5, "group": "T", "priority": "high", "desc": "支持AI运行时，包括基础库、扩展库和算子库，满足支持GPU大模型的加载。" },
                { "id": "大小模型推理及小模型训练任务调度框架", "layer": 5, "group": "T", "priority": "high", "desc": "实现多模型（包括大/小模型）任务优先级调度服务，对业务应用提供推理用户接口层（pub/sub、rest接口）、多用户管理、安全审计、推理任务调度等。满足支持GPU多个小模型的并发推理、多个小模型任务优先级调度管理、推理任务时延保障。" },
                { "id": "大小模型推理服务和引擎", "layer": 5, "group": "T", "priority": "high", "desc": "基于Libtorch进行裁剪的小模型推理引擎，实现小模型推理支持CPU/GPU推理。支持大模型推理引擎（GPU），满足支持CPU/GPU小模型并发推理、支持GPU大模型加载推理。" },
                { "id": "小模型训练框架", "layer": 5, "group": "T", "priority": "high", "desc": "基于平台RSE框架（CPU）、AIH的小模型训练引擎（GPU）实现小模型在网元上的高性能训练，满足支持神经网络小模型的在线训练、支持小模型增训。" },
                { "id": "Agent框架（含SDK、记忆、工具）", "layer": 5, "group": "T", "priority": "medium", "desc": "通过Agent应用开发SDK，实现智能体Plan（ReActAgent、RAGAgent智能体运行逻辑）、Action、Skill、Memory等功能。实现Agent框架，支持Agent应用快速灵活部署，满足支持网元智能体框架。" },
                { "id": "Agent-TOOLS（MCP）", "layer": 5, "group": "T", "priority": "low", "desc": "通过MCP协议智能体实现外部能力调用，满足支持MCP协议。" },
                { "id": "电信级Agent-Mesh（A2A）", "layer": 5, "group": "T", "priority": "low", "desc": "通过A2A协议实现智能体高效协同，实现Agent之间的高性能通信，满足支持A2A协议。" },
                { "id": "AI协议网关", "layer": 5, "group": "T", "priority": "low", "desc": "支持A2A/MCP等协议网关，满足支持AI协议网关。" },
                { "id": "工作流框架(BPMN/Dify)", "layer": 5, "group": "T", "priority": "high", "desc": "支持BPMN/Dify工作流引擎基于BPMN和Dify业界通用协议，实现智能体的工作流可编排引擎功能。" },
                { "id": "规则引擎（Clips）", "layer": 5, "group": "T", "priority": "high", "desc": "支持规则引擎（Clips），满足支持规则库引擎CLIPS。" },
                { "id": "向量/图数据库", "layer": 5, "group": "T", "priority": "medium", "desc": "基于PG数据库提供嵌入式轻量化向量数据和图数据存储，满足支持图数据库、支持embeding模型的部署。" },
                { "id": "RAG检索增强生成", "layer": 5, "group": "T", "priority": "medium", "desc": "LiteRAG实现轻量级知识检索增强生成的能力。" },
                { "id": "模型验证与评估", "layer": 5, "group": "T", "priority": "high", "desc": "模型可用性评估模块，满足支持模型验证和可用性评估、支持小模型增训及可用性评估。" },
                { "id": "模型部署与管理", "layer": 5, "group": "T", "priority": "high", "desc": "AI模型管理组件，实现大小模型统一管理：下载、部署、激活、卸载、删除、状态管理等。实现模型在线更新、A/B测试，满足支持小模型生命周期管理、支持模型A/B版本。" },
                { "id": "Agent管理", "layer": 5, "group": "T", "priority": "medium", "desc": "实现Agent运行时管理、AI知识资产管理等功能。" },
                { "id": "QoAIS管理", "layer": 5, "group": "T", "priority": "medium", "desc": "为了实现以任务为中心的工作流，从AI服务的QoS、AI任务的QoS和AI资源的QoS三个层次实现对AI四要素的编排，包括连接、数据、算力、算法。" },
                { "id": "AI可观测性", "layer": 5, "group": "T", "priority": "medium", "desc": "AI可观测性使能够对AI服务的状态、性能和资源使用情况进行有效监控和度量，包括模型推理、训练、Agent运行等。" }
]
                
            ],
            links: [
                // 【新特性展示】使用数组一次性配置“一对多”
                { source: "体验保障", target: ["体验保障推理诉求", "体验保障数据量诉求"] },
                { source: "智能节能", target: ["智能节能推理诉求"] },
                { source: "移动性寻优", target: ["移动性寻优推理诉求", "移动性寻优训练诉求", "移动性寻优优先级策略诉求"] },
                { source: "CA分流", target: ["CA分流推理诉求"] },
                { source: "通感一体化", target: ["通感一体化推理诉求", "通感一体化数据量诉求"] },
                { source: "智能运维", target: ["智能运维推理诉求"] },
                { source: "谱效提升", target: ["谱效提升推理诉求"] },
                
                // 网元智能方案：一条配置连接 6 个诉求节点
                { source: "网元智能解决方案生成", target: [
                    "网元智能解决方案生成推理诉求", 
                    "网元智能解决方案生成模型诉求", 
                    "网元智能解决方案生成AI网关诉求", 
                    "网元智能解决方案生成Agent诉求", 
                    "网元智能解决方案生成安全隔离诉求", 
                    "网元智能解决方案生成图数据库诉求"
                ]},
                
                { source: "体验保障推理诉求", target: ["小模型生命周期管理", "CPU小推理引擎","GPU小推理引擎"] },
                { source: "体验保障数据量诉求", target: ["数据传输通道", "数据传输总线"] },
                { source: "智能节能推理诉求", target:  ["小模型生命周期管理", "CPU小推理引擎","GPU小推理引擎"] },
                { source: "移动性寻优推理诉求", target:  ["数据传输总线", "小模型生命周期管理","CPU小推理引擎","小模型加载","小模型并发推理","小模型任务调度","GPU小推理引擎"] },
                { source: "移动性寻优训练诉求", target:  ["数据传输总线", "小模型在线训练","小模型增训及评估","A/B版本"] },
                { source: "移动性寻优优先级策略诉求", target:  ["QoAIS"] },
                { source: "CA分流推理诉求", target:  ["数据传输总线", "小模型生命周期管理","CPU小推理引擎","小模型加载","小模型并发推理","GPU小推理引擎","QoAIS"] },
                { source: "通感一体化推理诉求", target:  ["数据传输总线", "小模型加载","小模型并发推理","GPU小推理引擎","大小模型并发推理"] },
                { source: "通感一体化数据量诉求", target:  ["数据传输通道"] },
                { source: "智能运维推理诉求", target:  ["数据传输总线", "小模型生命周期管理","CPU小推理引擎","GPU小推理引擎","QoAIS"] },
                { source: "谱效提升推理诉求", target:  ["数据传输总线", "小模型生命周期管理","CPU小推理引擎","GPU小推理引擎","QoAIS"] },
                { source: "网元智能解决方案生成推理诉求", target:  ["GPU大模型加载", "大小模型并发推理"] },
                { source: "网元智能解决方案生成模型诉求", target:  ["embeding"] },
                { source: "网元智能解决方案生成AI网关诉求", target:  ["A2A&MCP", "AI协议网关"] },
                { source: "网元智能解决方案生成Agent诉求", target:  ["Agent框架"] },
                { source: "网元智能解决方案生成安全隔离诉求", target:  ["规则库引擎"] },
                { source: "网元智能解决方案生成图数据库诉求", target:  ["图数据库"] },
            ]
        };
        /**
         * 数据平铺函数 (First Principles of Data Transformation)
         * 将逻辑层的一对多配置平铺为物理层的一对一链路
         */
        function flattenLinks(links) {
            const flat = [];
            links.forEach(link => {
                if (Array.isArray(link.target)) {
                    link.target.forEach(t => {
                        flat.push({ source: link.source, target: t });
                    });
                } else {
                    flat.push(link);
                }
            });
            return flat;
        }

        /**
         * ==========================================
         * 渲染引擎 (D3.js Implementation)
         * ==========================================
         */
        const apiKey = ""; 
        const width = window.innerWidth;
        const height = window.innerHeight;

        const baseColors = { S: "#818cf8", R: "#34d399", C: "#fbbf24", T: "#f87171" };

        const getNodeColor = (d) => {
            const base = baseColors[d.group];
            if (d.layer === 3 && d.priority) {
                const colorObj = d3.color(base);
                if (d.priority === "high") return colorObj.darker(0.8).toString();
                if (d.priority === "medium") return colorObj.toString();
                if (d.priority === "low") return colorObj.brighter(1.2).toString();
            }
            return base;
        };

        const svg = d3.select("#graph-container").append("svg")
            .attr("width", width).attr("height", height)
            .attr("viewBox", [0, 0, width, height]);

        const layers_names = ["场景层 (Scenarios)", "业务诉求层 (Requirements)", "平台能力层 (Capabilities)", "架构技术层 (Technologies)"];
        layers_names.forEach((l, i) => {
            const h = height / 4;
            svg.append("rect")
                .attr("class", "layer-bg")
                .attr("x", 50).attr("y", h * i + 15)
                .attr("width", width - 100).attr("height", h - 30).attr("rx", 24);
            
            svg.append("text")
                .attr("class", "layer-label")
                .attr("x", width - 80).attr("y", h * i + (h / 2))
                .attr("text-anchor", "end").attr("dominant-baseline", "middle")
                .text(l);
        });

        const container = svg.append("g");

        // 使用平铺后的链路数据进行仿真
        const simulation = d3.forceSimulation(JSON.parse(JSON.stringify(KNOWLEDGE_BASE.nodes)))
            .force("link", d3.forceLink(flattenLinks(KNOWLEDGE_BASE.links)).id(d => d.id).distance(100))
            .force("charge", d3.forceManyBody().strength(-450))
            .force("x", d3.forceX(width * 0.45).strength(0.1))
            .force("y", d3.forceY(d => (height / 4) * (d.layer - 1) + (height / 8)).strength(2.5))
            .force("collision", d3.forceCollide().radius(50));

        const link = container.append("g")
            .selectAll("line").data(simulation.force("link").links()).join("line")
            .attr("class", "link").attr("stroke", "#1e293b").attr("stroke-width", 1.2);

        const drag = d3.drag()
            .on("start", (event, d) => {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x; d.fy = d.y;
            })
            .on("drag", (event, d) => { d.fx = event.x; d.fy = event.y; })
            .on("end", (event, d) => { if (!event.active) simulation.alphaTarget(0); d.fx = null; d.fy = null; });

        const node = container.append("g")
            .selectAll("circle").data(simulation.nodes()).join("circle")
            .attr("class", "node").attr("r", 10)
            .attr("fill", d => getNodeColor(d))
            .attr("stroke", d => d3.color(getNodeColor(d)).brighter(0.5))
            .call(drag)
            .on("click", (e, d) => selectNode(d))
            .on("mouseover", showTooltip).on("mouseout", hideTooltip);

        const label = container.append("g")
            .selectAll("text").data(simulation.nodes()).join("text")
            .attr("class", "label").attr("text-anchor", "middle").attr("dy", 24)
            .text(d => d.id.length > 10 ? d.id.substring(0,9) + "..." : d.id);

        simulation.on("tick", () => {
            link.attr("x1", d => d.source.x).attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x).attr("y2", d => d.target.y);
            node.attr("cx", d => d.x).attr("cy", d => d.y);
            label.attr("x", d => d.x).attr("y", d => d.y);
        });

        function selectNode(d) {
            const currentLinks = simulation.force("link").links();
            const connectedLinks = currentLinks.filter(l => l.source.id === d.id || l.target.id === d.id);
            const connectedNodeIds = new Set(connectedLinks.flatMap(l => [l.source.id, l.target.id]));
            
            node.style("opacity", n => connectedNodeIds.has(n.id) || n.id === d.id ? 1 : 0.05)
                .style("filter", n => connectedNodeIds.has(n.id) || n.id === d.id ? "none" : "grayscale(1)");
            
            link.attr("class", l => (l.source.id === d.id || l.target.id === d.id) ? "link active" : "link")
                .style("stroke", l => (l.source.id === d.id || l.target.id === d.id) ? getNodeColor(d) : "#1e293b");
            
            document.getElementById('ai-placeholder').classList.add('hidden');
            const responseArea = document.getElementById('ai-response-area');
            responseArea.classList.remove('hidden');
            responseArea.innerHTML = `
                <div class="flex items-center gap-3 mb-4">
                    <div class="w-1.5 h-6 bg-blue-500 rounded-full"></div>
                    <span class="text-white font-bold text-[14px]">${d.id}</span>
                </div>
                <div class="bg-slate-800/40 rounded-xl p-4 border border-slate-700/50">
                    <p class="text-slate-300 text-[12px] leading-relaxed font-light">${d.desc}</p>
                </div>
            `;
            document.getElementById('ai-actions').classList.remove('hidden');
            window.selectedNodeData = d;
        }

        const tooltip = d3.select("#tooltip");
        function showTooltip(event, d) {
            tooltip.style("display", "block").html(`
                <div class="flex items-center gap-2 mb-2">
                    <div class="w-2 h-2 rounded-full" style="background:${getNodeColor(d)}"></div>
                    <div class="text-white font-bold text-xs">${d.id}</div>
                </div>
                <div class="text-[11px] text-slate-400 leading-normal pt-2">${d.desc}</div>
            `);
            tooltip.style("left", `${event.pageX + 20}px`).style("top", `${event.pageY - 20}px`);
        }
        function hideTooltip() { tooltip.style("display", "none"); }

        document.getElementById('btn-path-insight').addEventListener('click', async () => {
            const nodeData = window.selectedNodeData;
            if (!nodeData) return;
            const indicator = document.getElementById('indicator');
            const responseArea = document.getElementById('ai-response-area');
            indicator.innerText = "Analyzing Topology...";
            indicator.classList.add('ai-pulse');
            
            try {
                const prompt = `作为专家，请分析 "${nodeData.id}"。这个节点体现了如何通过解耦配置实现“一对多”的高效建模。约 150 字。`;
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: prompt }] }],
                        systemInstruction: { parts: [{ text: "你是资深架构专家。" }] }
                    })
                });
                const result = await response.json();
                const text = result.candidates?.[0]?.content?.parts?.[0]?.text || "Fail.";
                responseArea.innerHTML += `<div class="mt-5 prose prose-invert prose-xs text-[11px]">${text}</div>`;
                indicator.innerText = "Ready";
            } catch (e) {
                indicator.innerText = "Error";
            } finally {
                indicator.classList.remove('ai-pulse');
            }
        });

        window.addEventListener('resize', () => { location.reload(); });
    </script>
</body>
</html>
